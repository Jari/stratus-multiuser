package {	import flash.display.MovieClip;	import flash.net.NetConnection;	import flash.net.NetStream;	import flash.events.NetStatusEvent;	import flash.events.MouseEvent;	public class StratusTest extends MovieClip	{		// stratus address, hosted by Adobe		private var connectUrl:String = "rtmfp://stratus.adobe.com";					// developer key, please insert your developer key here		private const DeveloperKey:String = "";					// please insert your webservice URL here for exchanging				//Not required for this example		private const WebServiceUrl:String = "";			// this is the connection to stratus		private var netConnection:NetConnection;						// after connection to stratus, publish listener stream to wait for incoming call 		private var listenerStream:NetStream;				// caller's incoming stream that is connected to callee's listener stream		private var controlStream:NetStream;				// outgoing media stream (audio, video, text and some control messages)		private var outgoingStream:NetStream;				// incoming media stream (audio, video, text and some control messages)		private var incomingStream:NetStream;						// login/registration state machine		private var loginState:int;				private const LoginNotConnected:int = 0;		private const LoginConnecting:int = 1;		private const LoginConnected:int = 2;		private const LoginDisconnecting:int = 3;				// call state machine		private var callState:int;				private const CallNotReady:int = 0;		private const CallReady:int = 1;		private const CallCalling:int = 2;		private const CallRinging:int = 3;		private const CallEstablished:int = 4;		private const CallFailed:int = 5;				private var remoteName:String = "";				private var userName:String;				private var connectedUsers:Array;				public function StratusTest()		{			onConnect();		}				private function onConnect():void		{			connectedUsers = new Array();						netConnection = new NetConnection();			netConnection.addEventListener(NetStatusEvent.NET_STATUS, netConnectionHandler);			netConnection.connect(connectUrl + "/" + DeveloperKey);						btnConnect.addEventListener(MouseEvent.CLICK, onConnectRequest);			btnSend.addEventListener(MouseEvent.CLICK, onSend);				}				private function onConnectRequest(e:MouseEvent):void		{			if(userNameInputTxt.text != "")			{				statusTxt.appendText("\nPlacing Call....\n");								userName = userNameInputTxt.text;							placeCall(peerIdTxt.text);							}		}				private function netConnectionHandler(event:NetStatusEvent):void		{			//status("NetConnection event: " + event.info.code + "\n");						statusTxt.appendText("NetConnection event: " + event.info.code + "\n");			           	switch (event.info.code)           	{               	case "NetConnection.Connect.Success":               		statusTxt.appendText("Stratus Connection Successful\n");					statusTxt.appendText("Your Peer ID:\n");					statusTxt.appendText(netConnection.nearID);										connectSuccess();                   	break;                   	                case "NetConnection.Connect.Closed":					trace("NetConnection.Connect.Closed");                    //loginState = LoginNotConnected;                    //callState = CallNotReady;                    break;                    	                case "NetStream.Connect.Success":					trace("NetStream.Connect.Success " + event.info.stream.farID);                    // we get this when other party connects to our control stream our outgoing stream                    //status("Connection from: " + event.info.stream.farID + "\n");                   	break;                    	                case "NetConnection.Connect.Failed":					trace("NetConnection.Connect.Failed");                    //status("Unable to connect to " + connectUrl + "\n");                    //loginState = LoginNotConnected;                    break;                    	                case "NetStream.Connect.Closed":					trace("NetStream.Connect.Closed");                    //onHangup();                    break;            }        }				// connection to stratus succeeded and we register our fingerprint with a simple web service		// other clients use the web service to look up our fingerprint		private function connectSuccess():void		{			//status("Connected, my ID: " + netConnection.nearID + "\n");                            /*idManager = new HttpIdManager();            idManager.addEventListener("registerSuccess", idManagerEvent);            idManager.addEventListener("registerFailure", idManagerEvent);            idManager.addEventListener("lookupFailure", idManagerEvent);            idManager.addEventListener("lookupSuccess", idManagerEvent);            idManager.addEventListener("idManagerError", idManagerEvent);              	            idManager.service = WebServiceUrl;            idManager.register(userNameInput.text, netConnection.nearID);*/			//if registerSuccess then complete registration ... listen for connections			completeRegistration();		}						private function completeRegistration():void		{			// start the control stream that will listen to incoming calls			listenerStream = new NetStream(netConnection, NetStream.DIRECT_CONNECTIONS);			listenerStream.addEventListener(NetStatusEvent.NET_STATUS, listenerHandler);			//listenerStream.publish("control" + userNameInput.text);			listenerStream.publish("control" + "test");									var c:Object = new Object			c.onPeerConnect = function(caller:NetStream):Boolean			{				trace("Caller connecting to listener stream: " + caller.farID + "\n");											if (callState == CallReady)				{					callState = CallRinging;													// callee subscribes to media, to be able to get the remote user name					incomingStream = new NetStream(netConnection, caller.farID);					incomingStream.addEventListener(NetStatusEvent.NET_STATUS, incomingStreamHandler);					incomingStream.play("media-caller");										// set volume for incoming stream					//var st:SoundTransform = new SoundTransform(speakerVolumeSlider.value);					//incomingStream.soundTransform = st;													//incomingStream.receiveAudio(false);					//incomingStream.receiveVideo(false);													var i:Object = new Object;					i.onIncomingCall = function(caller:String):void					{						if (callState != CallRinging)						{							trace("onIncomingCall: Wrong call state: " + callState + "\n");							return;						}						remoteName = caller;														statusTxt.appendText("Incoming call from: " + caller + "\n");													if(userNameInputTxt.text != "")						{														userName = userNameInputTxt.text;							acceptCall();						}									}										i.onIm = function(name:String, text:String):void					{						statusTxt.appendText("Test complete Registration\n");																			chatTxt.appendText(name + ": " + text + "\n");					}					incomingStream.client = i;													return true;				}									trace("onPeerConnect: all rejected due to state: " + callState + "\n");					return false;			}									listenerStream.client = c;									callState = CallReady;		}		private function listenerHandler(event:NetStatusEvent):void		{			trace("Listener event: " + event.info.code + "\n");		}				private function controlHandler(event:NetStatusEvent):void		{			trace("Control event: " + event.info.code + "\n");		}				private function outgoingStreamHandler(event:NetStatusEvent):void		{			trace("Outgoing stream event: " + event.info.code + "\n");        	switch (event.info.code)        	{        		case "NetStream.Play.Start":        			if (callState == CallCalling)        			{        				outgoingStream.send("onIncomingCall", userNameInputTxt.text);        			}        			break;        	}		}				private function incomingStreamHandler(event:NetStatusEvent):void		{			trace("Incoming stream event: " + event.info.code + "\n");        	switch (event.info.code)        	{        		case "NetStream.Play.UnpublishNotify":        			//onHangup();        			break;         	}		}		private function placeCall(identity:String):void		{				connectedUsers.push(identity);									if (identity.length != 64)			{					trace("Invalid remote ID, call failed\n");				callState = CallFailed;				return;			}									// caller subsrcibes to callee's listener stream 			controlStream = new NetStream(netConnection, identity);			controlStream.addEventListener(NetStatusEvent.NET_STATUS, controlHandler);			controlStream.play("control" + "test");									// caller publishes media stream			outgoingStream = new NetStream(netConnection, NetStream.DIRECT_CONNECTIONS);			outgoingStream.addEventListener(NetStatusEvent.NET_STATUS, outgoingStreamHandler);			outgoingStream.publish("media-caller");									var o:Object = new Object			o.onPeerConnect = function(caller:NetStream):Boolean			{				statusTxt.appendText("Callee connecting to: " + caller.farID + "\n");					           							return true; 			}			outgoingStream.client = o;																// caller subscribes to callee's media stream			incomingStream = new NetStream(netConnection, identity);			incomingStream.addEventListener(NetStatusEvent.NET_STATUS, incomingStreamHandler);			incomingStream.play("media-callee");						// set volume for incoming stream			//var st:SoundTransform = new SoundTransform(speakerVolumeSlider.value);			//incomingStream.soundTransform = st;									var i:Object = new Object;			i.onCallAccepted = function(callee:String):void			{				if (callState != CallCalling)				{					trace("onCallAccepted: Wrong call state: " + callState + "\n");					return;				}							        		callState = CallEstablished;        															trace("Call accepted by " + callee + "\n");			}						// Handles incoming messages			i.onIm = function(name:String, text:String):void			{												if(name == "|conn|")				{					statusTxt.appendText("PlaceCall second call !!!!!!!!!!!!!!!!!!!!!!!!!!!\n" + text + "\n");					placeCall(text);				}				else				{					chatTxt.text += name + ": " + text + "\n";				}								//usersTxt.text.appendText(name + "");				//textOutput.text += name + ": " + text + "\n";			}			incomingStream.client = i;									//remoteName = user;			callState = CallCalling;								}				private function acceptCall():void		{										// callee publishes media			outgoingStream = new NetStream(netConnection, NetStream.DIRECT_CONNECTIONS);			outgoingStream.addEventListener(NetStatusEvent.NET_STATUS, outgoingStreamHandler);			outgoingStream.publish("media-callee");						var o:Object = new Object			o.onPeerConnect = function(caller:NetStream):Boolean			{				statusTxt.appendText("Caller connecting: " + caller.farID + "\n");							           							return true; 			}			outgoingStream.client = o;						outgoingStream.send("onCallAccepted", userName);														callState = CallEstablished;						if(connectedUsers.length > 0)				outgoingStream.send("onIm", "|conn|", connectedUsers[0]);		}				// sending text message		private function onSend(e:MouseEvent):void		{						var msg:String = sendTxt.text; 			if (msg.length != 0 && outgoingStream)			{				chatTxt.text += msg + "\n";				outgoingStream.send("onIm", userName, msg);				sendTxt.text = "";			}		}	}}